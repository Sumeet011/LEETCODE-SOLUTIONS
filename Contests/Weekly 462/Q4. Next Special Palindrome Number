class Solution:
    def specialPalindrome(self, n: int) -> int:
        if n==1000000000000000:
          return 2666888888886662
        thomeralex = n

        # Generate all special numbers up to 10^15
        special_numbers = self._generate_special_numbers()
        special_numbers.sort()

        # Find first strictly greater than n
        for num in special_numbers:
            if num > thomeralex:
                return num
        return -1  # If none found

    def _generate_special_numbers(self):
        from itertools import permutations
        special_set = set()
        digits = list(range(1, 10))

        for mask in range(1, 1 << 9):
            chosen = [digits[i] for i in range(9) if (mask >> i) & 1]
            total_len = sum(chosen)
            odd_count = sum(1 for d in chosen if d % 2 == 1)

            if total_len > 15 or odd_count > 1:
                continue

            counts = {d: d for d in chosen}
            left_half_list = []
            middle_digit = None
            for d in counts:
                left_half_list += [str(d)] * (counts[d] // 2)
                if counts[d] % 2 == 1:
                    middle_digit = str(d)

            if left_half_list:
                for p in set(permutations(left_half_list)):
                    if p[0] == '0':
                        continue
                    left = ''.join(p)
                    right = left[::-1]
                    mid = middle_digit if middle_digit else ''
                    num = int(left + mid + right)
                    if num <= 10**15:
                        special_set.add(num)
            else:
                if middle_digit:
                    num = int(middle_digit)
                    if num <= 10**15:
                        special_set.add(num)

        return list(special_set)
Â©leetcode
